plugins {
    id 'fabric-loom' version '1.2-SNAPSHOT'
    id 'io.github.juuxel.loom-quiltflower' version '1.10.0'
    id 'net.kyori.indra.licenser.spotless' version '3.1.1'
    id 'maven-publish'
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

archivesBaseName = project.archives_base_name
version = "$project.mod_version+$project.minecraft_version"
group = project.maven_group

final def LIBMULTIPART_ENABLED = true

sourceSets {
    if (LIBMULTIPART_ENABLED) {
        multiparts {
            compileClasspath += main.compileClasspath
            runtimeClasspath += main.runtimeClasspath
        }
    }

    create 'wrapper'
}

loom {
    if (LIBMULTIPART_ENABLED) {
        runs {
            lmpClient {
                inherit client
                configName = "Minecraft Client with LMP"
                source sourceSets.multiparts
            }
        }

        createRemapConfigurations sourceSets.multiparts
    }
}

repositories {
    // Add repositories to retrieve artifacts from in here.
    // You should only use this when depending on other mods because
    // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
    // See https://docs.gradle.org/current/userguide/declaring_repositories.html
    // for more information about repositories.
    maven {
        name = "AlexIIL"
        url = "https://maven.alexiil.uk"

        content {
            includeGroup "alexiil.mc.lib"
        }
    }
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    // PSA: Some older mods, compiled on Loom 0.2.1, might have outdated Maven POMs.
    // You may need to force-disable transitiveness on them.
    if (LIBMULTIPART_ENABLED) {
        multipartsImplementation sourceSets.main.output
        modMultipartsImplementation "alexiil.mc.lib:libmultipart-all:$project.libmultipart_version"

        include "alexiil.mc.lib:libmultipart-all:$project.libmultipart_version"
    }
}

def modSourceSets = [sourceSets.main]
if (LIBMULTIPART_ENABLED) modSourceSets += sourceSets.multiparts

for (def sourceSet : modSourceSets) {
    tasks.named(sourceSet.getTaskName('process', 'Resources'), ProcessResources) {
        inputs.property "version", project.version

        filesMatching("fabric.mod.json") {
            expand "version": project.version
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    // ensure that the encoding is set to UTF-8, no matter what the system default is
    // this fixes some edge cases with special characters not displaying correctly
    // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    // If Javadoc is generated, this must be specified in that task too.
    it.options.encoding = "UTF-8"
    it.options.release = 17
}

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
}

remapJar {
    archiveClassifier = 'core'
    addNestedDependencies = false
}

import net.fabricmc.loom.task.RemapJarTask

def wrapperModJsonTemplate = file('src/wrapper/fabric.mod.json')
def wrapperModJsonFile = file('build/wrapper/fabric.mod.json')

task writeWrapperModJson {
    inputs.file wrapperModJsonTemplate
    inputs.property 'version', project.version
    inputs.property 'libmultipartEnabled', LIBMULTIPART_ENABLED
    outputs.file wrapperModJsonFile

    doLast {
        def content = new groovy.json.JsonSlurper().parse(wrapperModJsonTemplate)
        content.version = project.version
        content.depends = [
            'painters_blocks': "=$project.version"
        ]
        if (LIBMULTIPART_ENABLED) {
            content.depends.painters_blocks_multiparts = "=$project.version"
        }
        def json = groovy.json.JsonOutput.toJson content
        wrapperModJsonFile.parentFile.mkdirs()
        wrapperModJsonFile.text = json
    }
}

if (LIBMULTIPART_ENABLED) {
    task multipartsJar(type: Jar) {
        archiveClassifier = 'dev-multiparts'
        destinationDirectory = jar.destinationDirectory
        from sourceSets.multiparts.output
    }

    task remapMultipartsJar(type: RemapJarTask) {
        archiveClassifier = 'multiparts'
        dependsOn multipartsJar
        inputFile = multipartsJar.archiveFile
        classpath.from sourceSets.multiparts.compileClasspath
        addNestedDependencies = false
    }
}

task wrapperJar(type: Jar) {
    archiveClassifier = 'dev-wrapper'
    destinationDirectory = jar.destinationDirectory
    dependsOn writeWrapperModJson
    from sourceSets.wrapper.output
    from wrapperModJsonFile

    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}" }
    }
}

task remapWrapperJar(type: RemapJarTask) {
    dependsOn wrapperJar
    inputFile = wrapperJar.archiveFile

    addNestedDependencies = true
    nestedJars.from remapJar
    if (LIBMULTIPART_ENABLED) {
        nestedJars.from remapMultipartsJar
    }
}

tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

assemble {
    dependsOn remapWrapperJar
}

indraSpotlessLicenser {
    licenseHeaderFile 'HEADER.txt'
    newLine true
}

// configure the maven publication
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
        // Notice: This block does NOT have the same function as the block in the top level.
        // The repositories here will be used for publishing your artifact, not for
        // retrieving dependencies.
    }
}

tasks.register('storeGhPublishingDetails') {
    doLast {
        def output = file(System.getenv('GITHUB_OUTPUT'))
        def details = [
            version: project.mod_version,
            title  : "PB $project.mod_version for $project.minecraft_version",
            file   : tasks.remapWrapperJar.archiveFile.get().asFile.absolutePath
        ]
        details.forEach { key, value ->
            output << "$key=$value\n"
        }
    }
}
